module VarikSysTools.Info.Temperature.CPU where
import Text.Read;
import Data.Scientific;

type ErrorCode = String;

-- | ni'o go ko'a goi la'oi .'cpuTemps'. me'oi .support. lo samcmu be
-- ko'e goi lo ciste poi se co'e la'oi .'cpuTemps'. gi ko'a me'oi
-- .'Right'. me'oi .return. lo liste be lo se kelvo be lo rucyca'a poi
-- se pilno ko'e
--
-- .i go ko'a na me'oi .support. lo samcmu be ko'e gi ko'a me'oi
-- .'Left'. me'oi .return. lo velcki be lo nu ko'a na me'oi .support. lo
-- samcmu be ko'e
cpuTemps :: IO (Either ErrorCode [Scientific]);
cpuTemps = pure $ Left "cpuTemps is unimplemented.";

-- | ni'o ganai ko'a goi lo skami poi vasru lo ganse poi se mapti la'oi
-- .OpenBSD. .e la'oi .@cpuTempsOpenBSD. gi'e se samcmu la'oi .OpenBSD.
-- cu co'e zo'oi. @cpuTempsOpenBSD@. gi la'oi .@cpuTempsOpenBSD@. me'oi
-- .return. lo lise be lo se kelvo be lo rucyca'a poi se pilno ko'a
cpuTempsOpenBSD :: IO (Either ErrorCode [Scientific]);
cpuTempsOpenBSD = (>>= sequence . map possiblyRead) <$> scout
  where {
    -- \| ni'o ro da poi mu'oi zoi. ('String', 'String') .zoi zo'u ge go
    -- ko'a goi la'oi .@possiblyRead@. snada lo nu bixygau da lo me'oi
    -- .'Scientific'. gi ko'a me'oi .'Right'. lo me'oi .'Scientific'.
    -- poi me'oi .equivalent. da gi go ko'a fliba lo nu bixygau da lo
    -- me'oi .'Scientific'. gi ko'a me'oi .'Left'. lo velski be lo nu
    -- ko'a fliba
    possiblyRead :: (String, String)
                 -> Either ErrorCode Scientific;
    possiblyRead t = maybe failMsg pure $ readMaybe $ snd t
      where {
        failMsg = Left $ concat [cong, fst t, inf, show (snd t), "."]; 
        inf = " contains the unparsable value ";
        cong = "possiblyRead: ";
    };

    -- \| ni'o ro da poi velski be lo nu la'oi .@cpuTempsOpenBSD@.
    -- fliba zo'u la'oi .@viet@. lidne pe'aru'e da gi'e indika le du'u
    -- da se me'oi .output. la'oi .@cpuTempsOpenBSD@.
    viet :: ErrorCode;
    viet = "cpuTempsOpenBSD: ";

    -- \| ni'o ro da poi me'oi .@scout@. zo'u gonai da me'oi .'IO'.
    -- me'oi .'Right'. lo'i .orsi be li re bei lo cmene be lo mu'oi
    -- zoi. @sysctl(8)@ .zoi snicne goi ko'a be'o bei lo se snicne
    -- be ko'a gi da me'oi .'IO'. me'oi .'Left'. lo velski be lo nu
    -- me'oi .@scout@. fliba
    scout :: IO (Either ErrorCode [(String, String)]);
    scout = fmap concat . sequence <$> mapM (\a -> recurse [] a 0) sysctlVars
      where {
        recurse :: [(String, String)]
                -> String
                -> Integer
                -> IO (Either ErrorCode [(String, String)]);
        recurse xs v n = fetch v n >>= maybeRec
          where {
            -- \| ni'o gonai ge ge ko'e goi lo konkatena be la'oi .@k@.
            -- bei lo sinxa be la'oi .@n@. cu cmene ko'i goi lo snicne
            -- poi se pilno la'o zoi. @sysctl(8)@ .zoi gi snada gi ko'a
            -- goi la'o zoi. @fetch k n@ .zoi me'oi .'IO'. me'oi .'Right'.
            -- lo .orsi be li re bei la'oi .@k@. bei lo se snicne be ko'i
            -- gi ko'a me'oi .'IO'. me'oi .'Left'. velski be lo nu fliba 
            fetch :: String
                  -> Integer
                  -> IO (Either ErrorCode (String, String));
            fetch _ _ = pure $ Left "fetch is unimplemented.";

            maybeRec :: Either ErrorCode (String, String)
                     -> IO (Either ErrorCode [(String, String)]);
            maybeRec = either (\_ -> pure $ pure xs) f
              where f t = recurse (t:xs) v (n + 1);
        };

        -- \| ni'o la'oi .@scout@. troci lo nu tcidu lo se mu'oi zoi.
        -- sysctl(8) .zoi snicne be lo se cmene be lo konkatena be lo ro
        -- se vasru be la'oi .@sysctlVars@. ku bei lo namcu ku ku po'o
        sysctlVars :: [String];
        sysctlVars = ["hw.sensors.cpu"];
    };
};

nfx :: Eq a => [a] -> [a] -> Bool;
nfx _ [] = False;
nfx a b = take (length a) b == a || nfx a (drop (length a) b);
